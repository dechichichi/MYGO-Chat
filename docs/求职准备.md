# 求职准备：后端开发 + 大模型方向（本项目）

---

## 一、简历上怎么写

### 项目名称

- **MyGO Chat**（或：基于 LLM 的多角色 Agent 对话系统）

### 一句话描述（建议直接抄）

> 使用 Go 实现的、支持工具调用与持久化记忆的对话 Agent 系统，采用 ReAct（推理-行动-观察）框架驱动多轮推理，集成四层角色 Prompt、情绪感知、反思机制与多 API 容错。

### 技术栈（简历列举）

Go、Gin、OpenAI 兼容 API、ReAct Agent 框架、Function Calling（工具调用）、Prompt 工程、SQLite 记忆存储、多 API 容错、LRU 缓存

### 职责 / 亮点（挑 2～3 条写进简历）

- 设计并实现 **ReAct 推理循环**（Thought → Action → Observation），将 Agent 工具调用统一到可复用的 `react` 包，支持多轮推理与观察、步骤可追溯。
- 实现 **Agent 工具系统**：记忆回忆/保存、歌词检索、氛围感知、回复反思等，与 OpenAI Function Calling 对接，由 ToolExecutor 统一执行并注入 Observation。
- 搭建 **四层角色 Prompt + 两层情绪分析**（规则 + LLM），保证角色一致性与情绪感知，并在 system 中注入 ReAct 行为说明。
- 实现 **多 API 源容错**（主/备/兜底）、LRU 缓存与 Jaccard 去重，提升可用性与成本控制。

---

## 二、面试前必须能讲清的点（体现「大模型开发了解」）

### 1. ReAct 是什么、你为什么用

- **ReAct**：Reasoning + Acting，让模型先「思考」再「行动」，根据「观察」再决定下一步。
- **和普通对话的区别**：不是一次调用就结束，而是「推理 → 可选工具调用 → 观察 → 再推理」的循环，直到给出最终答案。
- **在本项目里**：
  - **Thought** = 模型输出的 `content`（先想清楚要不要用工具、用哪个）。
  - **Action** = `tool_calls`（如 recall_memory、sense_atmosphere）。
  - **Observation** = 工具执行结果，追加回对话，让模型继续推理。
- **为什么用**：需要「先回忆/感知再回复」时，单次调用不够；ReAct 把「推理-行动-观察」标准化，便于扩展工具和调试（每步可追溯）。

**建议背一句总结**：  
「我们用一个独立的 `react` 包跑 ReAct 循环，Agent 只负责组消息、提供工具执行器和角色/情绪 Prompt，这样后端结构清晰，也方便以后接别的模型或任务。」

### 2. 工具调用（Function Calling）怎么接

- 模型返回的 `tool_calls` 里包含：`id`、`name`、`arguments`（JSON 字符串）。
- 后端要做的事：
  - 解析 `arguments` → 调用对应工具（如查 DB、搜歌词）→ 得到结果。
  - 按 OpenAI 约定，把结果以 `role: "tool"`、`tool_call_id` 对应地塞回 `messages`。
  - 再调一次模型，让它根据这些 Observation 继续推理或给出最终回复。
- **能说清**：「我们有一个统一的 ToolExecutor 接口，每个工具一个 handler，ReAct 循环里只负责按 name 派发、把结果写回 messages，不关心具体业务。」

### 3. Prompt 设计（角色 + 情绪 + ReAct）

- **角色**：四层（身份 → 思维框架 → 语言风格 → 回复规则），保证同一角色在不同轮次里表现一致。
- **情绪**：先规则（关键词）快速判断，必要时再调 LLM 做细粒度情绪，再在 system 里加「当前情绪 + 回应建议」。
- **ReAct**：在 system 里加一段「先思考再决定是否调用工具；若调用，下一轮会看到 Observation」的说明，让模型习惯输出 Thought + 可选的 Action。

**能说清**：「我们把角色设定、情绪指导和 ReAct 行为说明都放在 system prompt 里，user 只发当前一句；这样既控制成本，又让模型行为可预期。」

### 4. 记忆与多轮

- **短期**：当前会话的对话历史（或最近 N 条）放进 `messages`。
- **长期**：通过 `save_memory` / `recall_memory` 工具落库（如 SQLite），跨会话使用。
- **能说清**：「长记存在 DB，由工具读写；ReAct 里模型在需要时主动调 recall，我们只提供工具实现和 session 维度。」

### 5. 容错与成本（体现工程化）

- **多 API 源**：主 → 备 → 静态兜底，失败自动切换。
- **缓存**：对相同/相似请求做 LRU 缓存，减少重复调用。
- **去重**：对模型输出做 Jaccard 相似度检测，避免重复话术。

**能说清**：「大模型 API 不稳定、有延迟和成本，所以我们做了多源容错和缓存；去重是为了体验，避免连续几句很像。」

---

## 三、一页项目说明（可给面试官或作品集）

以下可直接复制为「项目说明」或 README 的一节。

```text
项目名称：MyGO Chat（基于 LLM 的多角色 Agent 对话系统）

技术亮点（大模型 / Agent 方向）
────────────────────────────────────────────────────────────
• ReAct 框架
  独立 react 包实现 Thought→Action→Observation 循环，Agent 对话统一经此驱动，
  支持多轮工具调用与步骤可追溯（API 返回 react_steps）。

• 工具调用
  与 OpenAI Function Calling 协议对接，实现记忆、检索、氛围感知等工具，
  由 ToolExecutor 统一执行与注入 Observation。

• Prompt 工程
  四层角色 Prompt + 情绪感知指导 + ReAct 行为说明，在 system 中一次注入，
  控制角色一致性与推理习惯。

• 记忆与多轮
  短期依赖对话历史，长期通过 save/recall 工具与持久化存储（SQLite）实现跨会话记忆。

• 工程化
  多 API 容错、LRU 缓存、输出去重，兼顾可用性与成本。
────────────────────────────────────────────────────────────
```

---

## 四、面试常见问题与回答要点

| 问题 | 回答要点 |
|------|----------|
| ReAct 和直接用一次 API 调用的区别？ | 一次调用只能「问一次答一次」；ReAct 支持多轮「推理→行动→观察」，适合需要查记忆、查外部数据再回答的场景。 |
| 工具调用失败怎么办？ | 把错误信息作为 Observation 原样返回给模型，让模型决定重试、换工具或直接回复；同时后端可打日志、告警。 |
| 如何控制 token 成本？ | 多轮只保留必要历史、长记用 recall 按需拉取、对重复/相似请求做缓存、简单情绪用规则避免调 LLM。 |
| 如何保证角色不崩？ | 四层 Prompt 固定人设与表达方式，反思工具可自检「是否符合角色」；重要回复可走反思再输出。 |
| 这个项目里你最有挑战的部分？ | 把「工具调用循环」抽象成通用 ReAct 框架（Model + Executor + Steps），并和现有角色、情绪、记忆无缝结合，同时保持 API 与前端兼容。 |
| 如何扩展新工具？ | 在 philosopher/tools.go 里加一个 Tool 定义（Name、Description、Parameters、Handler），ReAct 循环不用改，自动支持。 |

---

## 五、面试加分项（可主动提）

1. **接口与数据**：能现场打开 `/api/agent/chat` 的请求/响应，指出 `react_steps` 里 thought / action / observation 分别是什么。
2. **扩展性**：「加新工具只需在 tools 里注册 + 实现 Handler，ReAct 循环不用改。」
3. **可观测**：若已打日志，可提「每步 Thought/Action/Observation 可落库或打日志，便于排查和调优」。

---

## 六、关键代码位置（方便现场指认）

| 内容 | 位置 |
|------|------|
| ReAct 循环入口 | `react/loop.go`：`Run(input *RunInput)` |
| ReAct 行为说明 | `react/prompt.go`：`DefaultReActInstruction` |
| Agent 调用 ReAct | `philosopher/agent.go`：`Chat()` 内 `react.Run(reactInput)`、`reactToolExecutor()` |
| 工具定义与执行 | `philosopher/tools.go`：`GetAgentTools()`、`ExecuteTool()` |
| API 返回 react_steps | `api/handler.go`：`AgentChatResponse.ReActSteps` |

---

## 七、与项目文档的对应关系

- **技术实现细节**：见 [technical_design.md](./technical_design.md)（架构、ReAct、工具、讨论引擎、API 等）。
- **运行与接口**：见项目根目录 [README.md](../README.md)（快速开始、API 示例、项目结构、简历与面试向说明）。
